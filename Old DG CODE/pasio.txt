.TITLE  PASIO
        .ENT    CRE?D,CWR?D,MVC,TRTAB
;************************************************************
;
;       THIS SUBROUTINE DOES TERMINAL IO UNDER COBOL.
;
;
; AUTHOR. JAY ANDERSON --ATLANTIC SOFT DRINK COMPANY--.
;    CRE?D -- DO A SCREEN READ FROM COBOL
;    CWR?D - DO A SCREEN WRITE FROM COBOL
;
;  THIS SUBROUTINE PROVIDES SCREEN HANDLING FOR COBOL.
;  	DIRECT CURSOR POSITIONING AS WELL AS FULL
;       FUNCTION KEY HANDLING IS PROVIDED.
;       THE DATA IS PASSED AS TYPE $STRING VARIABLES.
; 	THE FUNCTION KEYS ARE PASSED AS FOLLOWS:
;
;                F1   F2  F3   F4   F5   F6   F7   F8
;    FN ONLY      2    3   4    5    6    7    8    9
;    SHIFTED     10   11  12   13   14   15   16   17
;    CNTL        18   19  20   21   22   23   24   25
;    CNTL&SHIFT  26   27  28   29   30   31   32   33
;
;	ESC GENERATES 1
;	CR      GENERATES -1
;	TAB     GENERATES -2
;	TIMEOUT GENERATES 99
;	ALL OTHERS GENERATE 0
;
;************************************************************
.LIN = -12.                     ;STACK ADDRESS
.LINL = 1.    			;1 BYTE
.COL = -14.			;STACK ADDRESS OF CHARACTER
.COLL = 1.			;1 BYTE
.STR = -16.			;9(4) COMP FOLLOWED BY STRING
.STRL = 258.			;MAX SIZE OF ALL
.DELIM = -18.			;DELIMITER 0 = CR,NL 1=ESC,2=F1..
.DELL = 6B10.			;9(9) COMP
.INPO = -20.
.COPT = -22.			;9(9) COMP --DISPLAY OPTION
	.NREL 1

CRE?D:  WSAVS   0               ; SAVE THE WORLD
	LWLDA	2,.COL,3	;GET BYTE POINTER OF COL
	WLDB	2,1		;GET THE BYTE FROM CALLER
 	WSBI    1,1		;CORRECT COL -1
	LLEFB	2,COLIN*2	;GET BYTE POINTER TO COL IN PACKET
        WSTB	2,1		;PUT IN PACKET

	LWLDA	2,.LIN,3	;GET BYTE POINTER OF LIN
	WLDB	2,1		;GET THE BYTE FROM CALLER
	WSBI	1,1
	LLEFB	2,(COLIN*2)+1	;GET BYTE POINTER TO LIN IN PACKET
        WSTB	2,1		;PUT IN PACKET

	LWLDA	2,.INPO,3	;REL CUR
	WMOVR	2		;WORD ADDR
	LWLDA	2,0,2		;REAL CUR
	LNSTA	2,SCRPA+?ESEP	;PUT IT BACK

	LLEF	2,CONPK+?ETSP	;ADDRESS OF EXTENSION PLACE
	LLEF	1,SCRPA		;ADDRESS OF EXT PLUS HIGH BIT
	WLDAI	1S0,0		;GET A HIGH BIT
	WIOR	0,1		;OR IT IN
	LWSTA	
		;RESET

	LWLDA	2,.COPT,3	;GET THE DISPLAY OPTION
	WMOVR    2		;WORD ADDRESS
	LWLDA	2,0,2		;GET VALUE
	WSNEI	99.,2		;IS IT 99
	WBR	ITIS99		;?
	LNLDA	1,FLGSR 	;GET FLAGS FOR EXTENDED IO
	WBR	NOT99
ITIS99: LNLDA	1,FLGSR1	;NO REDISPLAY OPTION
NOT99:
	LNSTA	1,SCRPA+?ESFC	;RESET PACKET

	LLEFB	2,BUFFB*2  	;GET BYTE ADDRESS OF BUFFER
	LWLDA	3,.STR,3	;LOAD DESTINATION AC
	WINC    3,3		;BP TO STRING
	WINC    3,3
        WPSH	2,3
	LDAFP	3
	LWLDA	2,.STR,3	;ADDRESS OF      STRING LENGTH
	WMOVR    2		;WORD ADDRESS
	LWSTA	2,CLEN		;ADDRESS OF LENGTH VARIABLE
	LNLDA	2,0,2		;LENGTH OF STRING TO READ
	WMOV	2,0        	;LENGTH OF MOVE
	WPOP	3,2
	WMOV	0,1		;LENGTH OF MOVE
	WCMV			;


;BLANK OUT INPUT STR
	LDAFP	3
	WLDAI	0,1		;GET A NULL
	LWLDA	3,.STR,3	;GET ADDRESS OF STRING
	WMOVR    3		;WORD ADDRESS
	LNLDA	2,0,3	;GET LENGTH OF STRING
	WINC	3,3		;NEXT WORD
	WLSHI	1,3		;BP TO STRING
	WSTB	3,1		;PUT IN FIRST ' '
	WMOV	2,0		;LENGTH OF MOVE
	WMOV	3,2		;LOAD DESTINATION AC
	WINC	2,2		;NEXT BYTE
	WMOV	0,1		;LENGTH OF MOVE
	WCMV			;BLANK OUT

	LDAFP   3
	LWLDA	2,.STR,3	;ADDRESS OF      STRING LENGTH
	WMOVR	2		;WORD ADDRESS
	LNLDA	2,0,2		;LENGTH OF STRING TO READ
	LNSTA	2,LEN		;KEEP FOR REFERENCE
	LLEFB	3,BUFFB*2	;READ BUFFER
	WADD	2,3		; ADD LENGTH TO READ TO BYTEPOINTER
				;TO POSITION INTO BUFFER
	WLDAI	177,1		;GET A DELETE CHAR
	WSTB	3,1		;STORE DELETE CHAR
	WINC	3,3		;NEXT BYTE
	WSTB	3,1		;STORE DELETE
	

        LNLDA   0,ONCE          ; CHECK TO
        WSEQ    0,0             ;  SEE IF I'VE
        WBR     FKTLO           ;   EVER RUN
        NLDAI   1,0             ;    BEFORE
        LNSTA   0,ONCE          ; SKIP THE OPEN IF I HAVE
;***
;?GCHR AC0 CONTAINS BYTE POINTER TO CONSOLE NAME
;      AC1 = ZERO FOR FLAGS TO GET CURRENT CHARACTERISTICS
	LLEFB	0,MYCON*2	;GET BYTE POINTER
	WSUB	1,1		;ZERO
	LLEF	2,THECHAR	;ADDRESS OF THE CHARACTERISTICS
	?GCHR			;GET CHARACTERISTICS
	WBR	FKZ1R		;WBR TO ERROR BRIDGE
	
;	WLDAI	?CST,1		;SIMULATE TABS
;	WBTZ	2,1		;TURN OFF
	WLDAI 	?CEB0,1		;ECHO ON
	WBTZ	2,1		;OFF
	WLDAI	?CEB1,1		;
	WBTO
	2,1		;OFF

	WINC	2,2		;POINT TO SECOND WORD OF CHARACTERISTICS
	WLDAI	?CFKT,1		;ALLOW FUNCTION KEYS AS DELIMITERS
	WBTO	2,1		;TURN ON BIT

	WLDAI	?CNRM,1		;NO MESSAGE RECEIVE
	WBTO	2,1		;TURN ON BIT
	
;TELL THE SYSTEM

	LLEF	2,THECHAR	;ADDRESS OF CHARS
	LLEFB	0,MYCON*2	;BYTE POINTER TO CONSOLE PORT
	WSUB	1,1		;CHANGE CHARS
	?SCHR			;SET EM
	WBR	FKZ1R		;ERROR BRIDGE
        ?OPEN   CONPK           ; LISTEN FOR
        WBR     FKZ1R           ;  AWHILE.......HUMMMMM?
	WBR	FKTLO
FKZ1R:	LJMP	ERX

FKTLO:
	
;MOVE IN DATA
	LDAFP	3		;FRAME POINTER
	LWLDA	2,.STR,3
	;GET ADDRESS   PASSED IN

FKTAG:  LLEF	2,CONPK
	LNLDA	0,?ICH,2	;GET CHANNEL
	WLDAI	?SDTO+?SDCN+?SDTI,1
	LLEF	2,DELIM
	?SDLM
	NOP
 	LLEF    2,CONPK         ; GET THE IO PACKET ADDRESS
        LLEFB   0,BUFFB*2       ; SET UP THE BUFFER
        LWSTA   0,?IBAD,2       ;  BYTE POINTER
        ?READ                   ; GIVE ME SOME, PLEASE....
        WBR     CHKTO           ; CHECK FOR TIMEOUT!
	WBR 	NOTTO
CHKTO:
	NLDAI	ERDTO,1		;GET ERROR CODE FOR TIME OUT
	WSEQ	0,1		;SKIP IF NOT TIME OUT
	WBR	FKZ1R		;PROCESS OTHER ERROR
	NLDAI	99.,0		;CODE FOR TIMEOUT
	LNSTA	0,FKEY		;SAVE FOR LATER
	LJMP	SETESC
	
NOTTO:
;MOVE IN DATA
	LDAFP	3		;FRAME POINTER
	LWLDA	2,.STR,3	;GET ADDRESS   PASSED IN
 	WMOVR	 2		;GET ADDRESS
	WINC	2,2		;POINT TO START OF DATA
	WLSHI	1,2		;BACK TO BP = DESTINATION OF MOVE
	LLEFB	3,BUFFB*2	;SOURCE OF MOVE
	LLEF	0,TRAN		;DELIMITER TABLE
	LNLDA	1,LEN		;GET LENGTH TO MOVE
	WCMT			;MOVE UNTIL <177> OR <036>
	LNLDA	0,LEN		;GET LEN BACK
				;COMPUTE ACTUAL LEN ENTERED AS
				;(LEN - AC1 + 1)
	WSUB	1,0
	WINC	0,0
	LWLDA	2,CLEN		;ADDRESS OF WHERE IT GOES
	LNSTA	0,0,2		;TUCK IT AWAY
	WLDB	3,0		;CHECK FOR ESCAPE KEY <33>
	WCLM	0,0
	.DWORD	33
	.DWORD	33
	WBR	CRR
	NLDAI	1,0		;MAKE ESCAPE CODE
	LNSTA	0,FKEY		;SAVE TEMP
	WBR	NCTR
CRR:	WCLM	0,0		;CHECK FOR CR
	.DWORD	15
	.DWORD	15
	WBR	CTAB
	NLDAI	-1,0		;SET -1
	LNSTA	0,FKEY
	WBR	NCTR		;CONTINUE
	
CTAB:	WCLM	0,0		;CHECK FOR TAB
	.DWORD	11
	.DWORD	11
	WBR	CNTRL
	NLDAI	-2,0		;SET -1
	LNSTA	0,FKEY
	WBR	NCTR		;CONTINUE

	
CNTRL:
	WCLM	0,0		;CHECK FOR ^
	.DWORD	27
	.DWORD  27
	WBR	DONA
	NLDAI   36.,0		;SET 36
	LNSTA	0,FKEY
	WBR	NCTR
DONA:	WCLM	0,0		;CHECK DOWN ARROW
	.DWORD	32
	.DWORD  32
	WBR	ALLOT
	NLDAI	35.,0		;SET 35
	LNSTA	0,FKEY
	WBR	NCTR
ALLOT:
	WSUB 	0,0		;MAKE ZERO TEMP
	LNSTA	0,FKEY		;TEST FKEY LATER
NCTR:
;AC3 POINTS TO <036> OR <177> NEXT CHAR IS FUNCTION KEY IF 36
	WINC	3,3		;POINT TO FUNCTION IF 36

	LNLDA	0,FKEY		;GET ESCAPE KEY BACK
	WSNEI	1,0		;IS IT ESCAPE SET
	WBR	SETESC		;IT WAS ESC
;
	WSNEI	-1,0		;IS IT CR
	WBR	SETESC		;SET CR ALSO

	WSNEI	-2,0		;IS IT TAB
	WBR	SETESC		;SET TAB ALSO

	WSNEI	99.,0		;IS IT TIME OUT
	WBR	SETESC
	
	WSNEI	35.,0		;IS IT DOWNARROW
	WBR	SETESC

	WSNEI	36.,0		;IS IT UPARROW
	WBR 	SETESC

	LLEF	2,SCRPA+?ESFC   ;GET ADDR OF FLAGS FROM EXTENTION
	LNLDA	2,0,2		;GET FLAGS
	WLDAI	?ESDD,1		;DID READ END IN DOUBLE DELIM
	WAND	2,1		;MASK OUT ALL OTHER BITS
	WSUB	0,0		;SET AC0 TO NO FUNCTION KEY WAS HIT
	WSNE	1,1		;NOT A BIT LEFT STANDING THEN SKIP
	WBR	SETNL		;YES SKIP THIS INSTRUCTION

;LOCATE THE DELIMITER AND MASK IT DOWN TO A NUMBER 0-??
;0 = NO DOUBLE DELIM 1= ESC, 2= F1 ... ETC.
;AC3 HAS FUNTION KEY POINTER ,LOAD INTO AC0
	WLDB	3,1		;GET KEY INTO 0

;FIGURE OUT KEY USED

CKKEY:	 WCLM    1,1             ;
        .DWORD  161             ;  FUNCTIONS
        .DWORD  173             ;  KEYS
        WBR     CKKEY0          ;
	NLDAI	157,0		;BASE FOR FUNCTION
        WBR     OKAY

CKKEY0: WCLM    1,1             ;
        .DWORD  141             ; SHIFTED FUNCTIONS
        .DWORD  153             ;  KEYS
        WBR     CKKEY1          ;
	NLDAI	127,0		;BASE FOR SHIFTED
        WBR     OKAY

CKKEY1: WCLM    1,1             ;
        .DWORD  61              ; CONTROLLED FUNCTION
        .DWORD  73              ;  KEYS
        WBR     CKKEY2          ;
	NLDAI   37,0		;BASE FOR CONTRL
        WBR     OKAY            ;

CKKEY2: WCLM    1,1             ;
        .DWORD  41              ; CONTROL/SHIFTED FUNCTION
        .DWORD  53              ;  KEYS
        WBR     OKAY1           ;
	NLDAI	7,0
	W
	OKAY
OKAY1:  WSUB	0,0		;ALL OTHERS ARE ZERO
	WBR	SETNL
;IF WE GET HERE ITS A AN UNSHIFTED KEY
OKAY:   WSUB	0,1             ;       IT WAS THE RIGHT ONE...
	WMOV	1,0
;SET NEWLINE OR CR WAS PRESSED
SETESC:
SETNL:
	LDAFP  3		;RESTORE FRAME POINTER
	LWLDA  2,.DELIM,3	;BP TO DELIM KEY
	SEX    0,0		;SIGN OUT TO 32
	WMOVR   2
	LWSTA  0,0,2		;GIVE TO CALLER

	LLEFB  2,COLIN*2	;GET BP TO COL FROM READ
	WLDB   2,1		;GET COL INTO AC1
	WINC   1,1		;CORRECT COL + 1
	LWLDA  2,.COL,3		;GET BP TO COL
	WSTB   2,1		;PUT INTO COBOL BUFFER

	LLEFB  2,(COLIN*2)+1	;GET BP TO LIN FROM READ
	WLDB   2,1		;GET LIN INTO AC1
	WINC   1,1		;CORRECT LIN
	LWLDA  2,.LIN,3		;GET BP TO LIN
	WSTB   2,1		;PUT INTO COBOL BUFFER

        LDAFP	3		;GET READY TO RETURN
	WRTN			;GO BACK

FKTER:  LJMP    ERX
********

CWR?D: WSAVS   0               ; SAVE THE WORLD
	LWLDA	2,.COL,3	;GET BYTE POINTER OF COL
	WLDB	2,1		;GET THE BYTE FROM CALLER
	WSBI	1,1		;CORRECT COL -1
	LLEFB	2,COLIN*2	;GET BYTE POINTER TO COL IN PACKET
        WSTB	2,1		;PUT IN PACKET

	LWLDA	2,.LIN,3	;GET BYTE POINTER OF LIN
	WLDB	2,1		;GET THE BYTE FROM CALLER
	WSBI	1,1		;CORRECT LINE -1
	LLEFB	2,(COLIN*2)+1	;GET BYTE POINTER TO LIN IN PACKET
        WSTB	2,1		;PUT IN PACKET

	LLEF	2,CONPK+?ETSP	;ADDRESS OF EXTENSION PLACE
	LLEF	1,SCRPA		;ADDRESS OF EXT PLUS HIGH BIT
	WLDAI	1S0,0		;GET A HIGH BIT
	WIOR	0,1		;OR IT IN
	LWSTA	1,0,2		;RESET

	LNLDA	1,FLGSW		;GET FLAGS FOR EXTENDED IO
	LNSTA	1,SCRPA+?ESFC	;RESET PACKET

	LWLDA	2,.STR,3	;ADDRESS      OF STRING LENGTH
	WMOVR    2		;WORD ADDRESS
	LNLDA	2,0,2		;LENGTH OF STRING TO WRITE
	LNSTA	2,CONPK+?IRLR	;PUT IN PACKET
	WMOV	2,0		;GET LENGTH TO AC0 AND AC1
	WMOV	2,1		;

	LDAFP	3		;GET FRAME POINTER RESTORED
	LWLDA	2,.STR,3	;GET ADDRESS OF      STR
	WMOVR	2
	WINC	2,2		;GET PAST LENGTH VAR
	WLSHI   1,2		;BYTE POINTER
	WMOV	2,3		;SOURCE IN 3
	LLEFB	2,BUFFB*2	;DESTINATION BUFF
	WCMV			;COPY BUFFER
	WSUB	0,0		;MAKE A NULL
	WSTB	2,0		;STUFF IT IN
	

        LNLDA   0,ONCE          ; CHECK TO
        WSEQ    0,0             ;  SEE IF I'VE
      

        NLDAI   1,0             ;    BEFORE
        LNSTA   0,ONCE          ; SKIP THE OPEN IF I HAVE

;***
;?GCHR AC0 CONTAINS BYTE POINTER TO CONSOLE NAME
;      AC1 = ZERO FOR FLAGS TO GET CURRENT CHARACTERISTICS
	LLEFB	0,MYCON*2	;GET BYTE POINTER
	WSUB	1,1		;ZERO
	LLEF	2,THECHAR	;ADDRESS OF THE CHARACTERISTICS
	?GCHR			;GET CHARACTERISTICS
	WBR	GKZ1R		;WBR TO ERROR BRIDGE
	
;	WLDAI	?CST,1		;SIMULATE TABS
;	WBTZ	2,1		;TURN OFF
	WLDAI 	?CEB0,1		;ECHO OFF
	WBTZ	2,1		;OFF
	WLDAI	?CEB1,1		;
	WBTO	2,1		;OFF

	WINC	2,2		;POINT TO SECOND WORD OF CHARACTERISTICS
	WLDAI	?CFKT,1		;ALLOW FUNCTION KEYS AS DELIMITERS
	WBTO	2,1		;TURN ON BIT

	WLDAI	?CNRM,1		;NO MESSAGE RECEIVE
	WBTO	2,1		;TURN ON BIT
	
;TELL THE SYSTEM

	LLEF	2,THECHAR	;ADDRESS OF CHARS
	LLEFB	0,MYCON*2	;BYTE POINTER TO CONSOLE PORT
	WSUB	1,1		;CHANGE CHARS
	?SCHR			;SET EM
	WBR	GKZ1R		;ERROR BRIDGE
        ?OPEN   CONPK           ; LISTEN FOR
        WBR     GKZ1R           ;  AWHILE.......HUMMMMM?
	WBR	GKTLO
GKZ1R:	LJMP	ERX

GKTLO:

GKTAG:  LLEF    2,CONPK         ; GET THE IO PACKET ADDRESS
        LLEFB   0,BUFFB*2       ; SET UP THE BUFFER
        LWSTA   0,?IBAD,2       ;  BYTE POINTER
        ?WRITE                  ; WRITE TO TERMINAL
        WBR     GKZ1R           ; WELL, I NEVER....!

        LDAFP	3		;GET READY TO RETURN
	WRTN			;GO BACK
**********

ERX:    LNLDA   2,FLAGS
HOME:   ?RETURN
        WBR     ERX
FLAGS:  .WORD   ?RFCF+?RFER+?RFEC

BYEBYE: WSUB    2,2             ; GOODBYE,
        ?RETURN                 ;  CRUEL
        WBR     BYEBYE          ;   WORLD!



; TO USE THIS ROUTINE FROM COBOL CODE THE STATMENT
;	CALL "MVC" USING FROM-ADDRESS TO-ADDRESS MOVE-LENGTH
; WHERE ALL THREE VARIABLES ARE OF THE FORMAT
;	01 FROM-ADDRESS
;	01 TO-ADDRESS
;	01 MOVE-LENGTH	PIC S9(9) COMP.

ARG1 = -12.
ARG2 = -14.
ARG3 = -16.



MVC:	WSAVS	0

	LWLDA	2,ARG3,3	; GET BYTE POINTER TO "LENGTH" ADDRESS
	WLSHI	-1,2		; CHANGE AC2 TO WORD ADDRESS
	LWLDA	1,0,2		; AC1 GETS ACTUAL LENGTH
	WMOV	1,0
	LWLDA	2,ARG2,3	; GET BYT


	LWLDA	3,ARG1,3	; GET BYTE POINTER TO "TO " ADDRESS

	WCMV			; MOVE CHARACTERS

	LDAFP	3
	WRTN

TRTAB:	WSAVS	0
;IN THE TRANSLATE TABLE MAKE A TAB A SPACE
	LLEFB	2,TRTBL*2	;BP TO TABLE BASE
	NLDAI	11,1	;GET A TAB CHARACTER
	WADD	1,2		;INDEX INTO TRTBL
	NLDAI	" ,1		;GET A SPACE
	WSTB	2,1		;PLACE IN TRTBL

	LWLDA	2,ARG3,3	; GET BYTE POINTER TO "LENGTH" ADDRESS
	WMOVR	2		; CHANGE AC2 TO WORD ADDRESS
	LWLDA	1,0,2		; AC1 GETS ACTUAL LENGTH
	WNEG	1,1		; TRANSLATE AND MOVE
	LWLDA	2,ARG2,3
	; GET BYTE POINTER TO DEST   ADDRESS

	LWLDA	3,ARG1,3	; GET BYTE POINTER TO SRC   ADDRESS
	LLEF 	0,TRADR  	; TRANSLATE TABLE ADDRESS OF POINTER
	WCTR			; TRANSLATE

	LDAFP	3
	WRTN

	.NREL
	.RDX 8.
	.A=0
	.B=1
	.TXTN 1
TRADR:	.DWORD TRTBL*2
TRTBL:
.DO 127.
	.TXT "<.A><.B>"
	.A=.A+2.
	.B=.B+2.
.ENDC
	.TXTN 0
	.TXT "<255><000>"

CONPK:
	.LOC	CONPK+?ICH
	.WORD	0
        .LOC    CONPK+?ISTI
        .WORD   ?OFIO+?RTDS+?IPKL
	.LOC	CONPK+?ISTO
	.WORD 	0
        .LOC    CONPK+?IMRS
        .WORD   -1
        .LOC    CONPK+?IBAD
        .DWORD  BUFFB*2
        .LOC    CONPK+?IRCL
        .WORD   -1
        .LOC    CONPK+?IRLR
        .DWORD  255.
        .LOC    CONPK+?IFNP
        .DWORD  CONNM*2
        .LOC    CONPK+?IDEL
        .DWORD  DELIM
	.LOC	CONPK+?ETSP
	.DWORD	SCRPA+1S0	;ADDRESS OF EXTENTION
	.LOC	CONPK+?IBLT
SCRPA:
	.LOC	SCRPA+?ESFC
	.WORD 	?ESSE+?ESCP+?ESED
	.LOC 	SCRPA+?ESEP
	.WORD	0
COLIN:	.LOC	SCRPA+?ESCR
	.WORD	0
	.LOC 	SCRPA+?EFMAX

FLGSW:	.WORD   ?ESED+?ESCP+?ESSE
FLGSR:	.WORD   ?ESSE+?ESCP+?ESED+?ESRD+?ESRP
FLGSR1:	.WORD   ?ESSE+?ESCP+?ESED+?ESRP
CONNM:  .TXT    /@CONSOLE/
BUFFB:  .BLK    1024.

FUNC:    .WORD 36                      ; 36
FKEY:    .WORD 0                       ; 0
LEN:	 .WORD	0
CLEN:	.DWORD 0

ONCE:    .WORD 0                  ; ONCE
MYCON:	.TXT /@CONSOLE/
THECHAR: .WORD  0
	 .WORD  0
	 .WORD  0


	.ENABLE WORD
;DELIMITER TABLE FOR <33> ,<36> AND <177>
TRAN:
	.RDX 2.
T00:    1111111111111100
T02:    1111001111110011
	.RDX 8.
T04:    0
T06: 	0
T08:    0
T10:    0
T12:    0
T14:   

T16:    1B15.
T18:    -1.
T20:    -1.
T22:    -1.
T24:    -1.
T26:    -1.
T28:    -1.
T30:	-1.

;ALL CHARS ARE DELIMS EXCEPT '_'  AND NORMAL DELIMS
UTRAN:
        1B0+1B10.+1B12.+1B13.
        1B7+1B10.+1B11.
        -1.
        -1.
	-1.
        -1.
        177776
        -1.
        1B15.
        -1.
        -1.
        -1.
        -1.
        -1.
        -1.
    	-1.

DELIM:
D00:    1B0+1B9.+1B10.+1B12.+1B13.
D02:    1B7+1B10.+1B11.
D04:    0
D06:	0
D08:    0
D10:    0
D12:    0
D14:    0
D16:    0
D18:    0.
D20:    0.
D22:    0.
D24:    0.
D26:    0.
D28:    0.
D30:	0.


        .END
